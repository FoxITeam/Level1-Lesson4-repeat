package ru.foxit.grayfox;

import java.util.Random;
import java.util.Scanner;

/**
 * Author XOGame.java - GrayFox | Ilya Lisin
 * Contact: Skype: foxygameskype | Telegram: +7(925)316-65-82 | vk: https://vk.com/exsperto1
 * GitHub: https://github.com/FoxITeam and https://github.com/GrayFoxIT
 * encoding: UTF-8, Comments, remarks in Russian.
 */

public class XOGame {
    // Процедурный стиль - это стиль в одном классе.
    // Для того, чтобы переменная была не изменяемой используется слово final
    // После присваивания значения такой переменной изменить его внутри кода невозможно.
    static char[][] map;
    static final int SIZE = 3;
    static final int DOTS_TO_WIN = 3;
    static final char DOT_EMPTY = '*';
    static final char DOT_X = 'x';
    static final char DOT_O = 'o';

    public static void main(String[] args) {
        initMap(); // С начало ее инициализируем, нашу карту.
        printMap(); // Потом ее напечатаем.

        while (true) {
            playerTurn(); // Первым делом ходит человек.
            printMap(); // Потом ее напечатаем. (отрисуем карту).
            if (checkWin(DOT_X)) { // Если крестик победил
                System.out.println("Победил человек"); // Печатаем
                break; // И выходим из цикла.
            }
            if (isMapFull()) { // Метод, который будет проверять, карта наша не заполнилась полностью?
                System.out.println("Ничья"); // Если заполнилась и никто не выиграл, пишет ничья!
                break; // И выходим из цикла.
            }
            aiTurn(); // Ходит компьютер.
            printMap(); // Потом ее напечатаем. (отрисуем карту).
            if (checkWin(DOT_O)) { // Проверка на нолик
                System.out.println("Победил компьютер"); // победил компьютер
                break; // И выходим из цикла.
            }
            if (isMapFull()) {
                System.out.println("Ничья");
                break; // И выходим из цикла.
            }
            // Если отработает один из брейков, то игра закончена.
        }
        System.out.println("Игра окончана!");
    }

    private static boolean isMapFull() {
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                if(map[i][j]==DOT_EMPTY){
                    return false; // Карта не заполнена!
                }
            }
        }
        return true; // Карта заполнена, ничья!
    }

    // В этом методе мы сказали - выделить память под массив, но не сказали какого размера будет массив.
    // В методе initMap - мы инициализировали массив и дали размер SIZE SIZE, то есть 3 на 3.
    // Далее 2 цикла, 1 цикл бегает по строкам, 2 цикл бегает по столбцам
    public static void initMap() {
        map = new char[SIZE][SIZE];
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                map[i][j] = DOT_EMPTY;
            }
        }
    }

    // Ниже мы выводим цифры, чтобы нам было понятно в какой строке и столбце лежит символ *, затем
    // заполняем наш массив звездочками, то есть мы сделали поле для игры в крестики нолики.
    public static void printMap() {
        System.out.print(" ");
        for (int i = 0; i < SIZE; i++) {
            System.out.print(" " + (i + 1));
        }
        System.out.println();
        // По транслитую, сорян!!
        for (int stolbec = 0; stolbec < SIZE; stolbec++) {
            // Возводим в скобки (i+1), так как чтобы все выражение не приводилось к строке, а то мы увидим
            // совсем другой результат.
            System.out.print((stolbec + 1) + " ");
            for (int stroki = 0; stroki < SIZE; stroki++) {
                System.out.print(map[stolbec][stroki] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    // Метод который отпределяет ход человека
    public static void playerTurn() {
        Scanner scanner = new Scanner(System.in);
        int x = 0;
        int y = 0;
        do {
            System.out.print("Введите коодинату X: ");
            x = scanner.nextInt() - 1;
            System.out.println();
            System.out.print("Введите коодинату Y: ");
            y = scanner.nextInt() - 1;
            // Этот метод isCellAvailable проверят доступность клетки на заполнение
            // ! знак говорит о том: Пока метод не true - или не false
            // ! по другому этот знак говорит нам о том, что это "не", обозначает отрицание
            // Не равно, не метод, восклицательный знак инвертирует
            // полученное значения. В место тру делает фолс и наоборот.
        } while (!isCellAvailable(x, y));
        map[x][y] = DOT_X;
        //scanner.close(); // При использовании сканера нужно его закрывать.
    }

    // Принято в джаве методы которые возвращают булеан boolean называть с переменной is
    // isCellAvailable - перевод с англ на русский - клеткаДоступна? с вопросительной интонацией
    private static boolean isCellAvailable(int x, int y) {
        if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) {
            return false;
        }
        if (map[x][y] == DOT_EMPTY) {
            return true;
        }
        return false;
    }

    // Напишем искуственный интелект!
    public static void aiTurn() {
        int x;
        int y;
        // Инициализируем рандом
        Random random = new Random();
        do {
            // Присваиваем значения переменным
            x = random.nextInt(SIZE);
            y = random.nextInt(SIZE);
            // Проверяем что данная координата доступная и если не доступна - заного присваиваем!
            // и так до тех пор пока не присвоиться.
        } while (!isCellAvailable(x, y));
        // И печатаем в подходящем координате наш нолик.
        map[x][y] = DOT_O;
    }

    // Определить победу теперь нужно! Кто победил, наш компьютер или Мы с Вами! Напишем хард кодный метод из
    // тех что нам предлагают
    public static boolean checkWin(char symb) {
        // Предлагаем перебрать все 8 условий
        // Есть тодо, она выделяется другим цветом в коде и не дает мимо него пройти.
        // Так же в идеи есть вкладка тодо, можно на нее перейти и тогда у нас будет указано
        // на какой строке, на каком месте вы оставили какую тудушку и когда
        // todo | дз типо епта, упростить через циклы =D
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
//        if (map[0][0] == symb && map[0][1] == symb && map[0][2] == symb) return true;
        return false;
    }
}

/**
 * Слишком дохрена заметок из todo!
 * Надо разделить их по категориям и пихать в отдельный класс, чтобы не мешались!
 * Категория 1 - Комбинации клавиш
 * Категория 2 - Определения
 * Категория 3 - Заметки
 */

/**
 * Важные заметки, которые очень пригодятся на следующих занятиях.
 * <p>
 * + что мы повторили или используем в коде
 * - то что мы не повторяли или не приходилось использовать в коде
 * o - то что мы узнали на этом уроке и нужно повторить на следующем.
 * ++ todo | ctrl + F2 - остановить проект.
 * ++ todo | fori - сокращение цикла for обычная, itar - сокрашения цикла for с массивом, iter - еще не изучали, хотя не пизжу, забыл =D
 * Примечание: fori sout psvm itar и подобные сокращения работают только в методах.
 * ++ todo | с помощью жука (дебагера) кликаем по нужному участку кода, запускаем и шагаем F8 по шагам, смотрим на выполнение кода.
 * ++ todo | alt + Enter (Наводим на if или switch и мы можем переконвертировать их) с if в switch или наоборот.
 * ++ todo | CTRL + / - комментирования выделенных строк в коде.
 * ++ todo | Название переменных и методов начинаются с маленькой буквой, в то время как классы начинаются с большой буквы.
 * -+ todo | CTRL + F - поиск, CTRL + R - замена слова.
 * +- todo | CTRL + SHIFT + ENTER - поставить точку с запятой и перейти на следующую строку.
 * ++ todo | CTRL + D - копировать ту строку, на которую мы нажали и оно вставит ее ниже.
 * ++ todo | Зажимаем ALT и выделяем, выделять будет квадратом.
 * ++ todo | Shift + F10 - запустить проект.
 * ++ todo | Shift + F6 - переименования название методов/переменных.
 * ++ todo | psvm - public static void Main
 * ++ todo | sout - System.out.println
 * ++ todo | Alt+ctrl+L - форматирование текста и кода в IDEA, удобная вещь.
 * ++ todo | Alt + Insert = Можно сгенерировать геттеры и сеттеры.
 * ++ todo | Что такое переменная - по факту это ссылка в адрес памяти и что по этому адресу лежит
 * ++ todo | определяется типом нашей переменной. Типы переменных бывают 2 видов - это
 * ++ todo | примитивные и ссылочные, их всего восемь.
 * ++ todo | Что такое метод - метод, он же в некоторых языках функция, это какое то поведение
 * ++ todo | если класс это описание объекта, допустим машина, то метод это его поведение, то что эта
 * ++ todo | машина может делать, например сигналить.
 * ++ todo | Что такое String в Java? Какой это тип данных?
 * ++ todo | String – это класс в Java, который прописан в пакете java.lang. Это не примитивный тип данных,
 * ++ todo | как int и long. Класс String представляет строковый набор символов.
 * ++ todo | Везде, где мы делаем константную проверку, используем свитч, это экономит ресурсы. if проверяет все, а вот свитч
 * ++ todo | остановиться на нужном условии и выйдет из блока кода, не станет дальше проверять, в отличии от if.
 * ++ todo | Рефакторинг это улучшение кода, когда вы его написали, код который работает, но скорее всего вы его с первого раза не написали
 * ++ todo | его идеально, нам нужно его обработать, обработка напильников, полировка, шлифовка, шпаклей херовка, цементировка, синонимыСловафрафаф тфу...
 * + todo | Случайные значения получаются с помощью класса рандом!
 * + todo | В джава всЁ объекты, кроме примитивных типов. Примитивные типы не объекты, но у них есть оболочки!
 * + todo | Одномерный массив это список, многомерный массив это таблица (матрица).
 * + todo | Полиморфизм - работа с несколькими типами, но в то же время у каждого типа будет свое уник. поведение.
 * + todo | Инкапсуляция - принцип обертывания данных (переменных) и кода в единое целое, создано для безопасности.
 * + todo | Пример инкапсуляции может быть геттеры и сеттеры.
 * + todo | Абстракции это процесс сокрытия деталей от пользователей, только функционал будет доступен пользователю.
 * + todo | ctrl + Alt + M - Прежде выделяем область и комбинацию. Она может выделенный фрагмент кода экстрактить в отдельный элемент кода.
 * + todo | * Некоторый код требует чтобы его писали в блоке кода трай кетч \ Безопасным считается код, который проверяется на наличие исключений (ошибок).
 * + todo | * Не безопасным считается код, который не проверяетмя, но может бросить исключения (ошибки).
 * + todo | * не безопасный код нужно писать Try catch, - попробовать try сделать что либо, если это не получиться
 * + todo | * catch - перехватить вылетевший экзепшен.
 * + todo | // Что такое форматированный ввод: Один из вариантов форматированного ввода в джаве
 * + todo | // Класс MessageFormat и его статический метод format позволяет подставлять аргументы
 * + todo | // переданные в данный метод. Данный метод формат уже принимает 2 аргумента (строку Pattern и имя str)
 * + todo | // Pattern = шаблон, это шаблон проектирования или паттер проектирования.
 * + todo | \\ Для того, чтобы обратиться к методу другого класса, нужно написать класс точка и название метода.
 * + todo | \\ Если этот метод не статический, то нужно создать экземпляр класса "new", если же он статический, то
 * + todo | \\ к нему достаточно обратиться через точку.
 * + todo | // В предыдущем прохождении джавы я не раздечал deepToString и toString = deepToString пишется когда 2 мерный массив,
 * + todo | // а toString пишется, когда одномерный массив!
 * + todo | Процедурный стиль - это стиль в одном классе.
 * + todo | Для того, чтобы переменная была не изменяемой используется слово final
 * + todo |  (!isCellAvailable) - "!" знак говорит о том: Пока метод не true - или не false
 * + todo |  ! по другому этот знак говорит нам о том, что это "не", обозначает отрицание
 * + todo |  Не равно, не метод, восклицательный знак инвертирует
 * + todo |  полученное значения. В место тру делает фолс и наоборот.
 * + todo |  Принято в джаве методы которые возвращают булеан boolean называть с переменной is
 * + todo |  isCellAvailable - перевод с англ на русский - клеткаДоступна? с вопросительной интонацией
 * + todo |  Но не все boolean могут быть вопросительными!
 */
